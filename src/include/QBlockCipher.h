/*
 * Copyright 2023 BrutalWizard (https://github.com/bru74lw1z4rd). All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy
 * in the file LICENSE in the source distribution
 */

#ifndef QBLOCKCIPHER_H
#define QBLOCKCIPHER_H

#include "QSimpleCrypto_global.h"

#include <QObject>

#include <memory>

#include <openssl/aes.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

namespace QSimpleCrypto {
class QSIMPLECRYPTO_EXPORT QBlockCipher {

#define aes128Rounds 10
#define aes192Rounds 12
#define aes256Rounds 14

public:
    QBlockCipher();

    ///
    /// \brief generateRandomSalt - Function generates salt (random bytes) by size.
    /// \param size - Size of generated bytes.
    /// \return Returns salt (random bytes).
    ///
    [[nodiscard]] static QByteArray generateSalt(const quint16& size = 16);

    ///
    /// \brief generateRandomSalt - Function generates salt (random private bytes) by size.
    /// \param size - Size of generated bytes.
    /// \return Returns salt (random private bytes).
    ///
    [[nodiscard]] static QByteArray generatePrivateSalt(const quint16& size = 16);

    ///
    /// \brief encryptAesBlockCipher - Function encrypts data with Aes Block Cipher algorithm.
    /// \param data - Data that will be encrypted.
    /// \param key - AES key. Example: "AABBCCEEFFGGHHKKLLMMNNOOPPRRSSTT"
    /// \param iv - Initialization vector. Example: "AABBCCEEFFGGHHKKLLMMNNOOPPRRSSTT"
    /// \param password - Encryption password.
    /// \param salt - Random delta. Example: "qwerty123" or another random bytes generated with QSimpleCrypto::QBlockCipher::generateSalt.
    /// \param rounds - Transformation rounds.
    /// \param chiper - Can be used with OpenSSL EVP_CIPHER (ecb, cbc, cfb, ofb, ctr) - 128, 192, 256. Example: EVP_aes_256_cbc().
    /// \param md - Hash algroitm (OpenSSL EVP_MD). Example: EVP_sha512().
    /// \return Returns encrypted data on success or "" on failure.
    ///
    [[nodiscard]] QByteArray encryptAesBlockCipher(const QByteArray& data, const QByteArray& key, const QByteArray& iv = "",
        const QByteArray& password = "", const QByteArray& salt = "", const qint32 rounds = aes256Rounds,
        const EVP_CIPHER* cipher = EVP_aes_256_cbc(), const EVP_MD* md = EVP_sha512());

    ///
    /// \brief decryptAesBlockCipher - Function decrypts data with Aes Block Cipher algorithm.
    /// \param data - Data that will be decrypted.
    /// \param key - AES key. Example: "AABBCCEEFFGGHHKKLLMMNNOOPPRRSSTT"
    /// \param iv - Initialization vector. Example: "AABBCCEEFFGGHHKKLLMMNNOOPPRRSSTT"
    /// \param password - Decryption password.
    /// \param salt - Random delta. Example: "qwerty123" or another random bytes generated with QSimpleCrypto::QBlockCipher::generateSalt.
    /// \param rounds - Transformation rounds.
    /// \param chiper - Can be used with OpenSSL EVP_CIPHER (ecb, cbc, cfb, ofb, ctr) - 128, 192, 256. Example: EVP_aes_256_cbc().
    /// \param md - Hash algroitm (OpenSSL EVP_MD). Example: EVP_sha512().
    /// \return Returns decrypted data on success or "" on failure.
    ///
    [[nodiscard]] QByteArray decryptAesBlockCipher(const QByteArray& data, const QByteArray& key, const QByteArray& iv = "",
        const QByteArray& password = "", const QByteArray& salt = "", const qint32 rounds = aes256Rounds,
        const EVP_CIPHER* cipher = EVP_aes_256_cbc(), const EVP_MD* md = EVP_sha512());
};
} // namespace QSimpleCrypto

#endif // QBLOCKCIPHER_H
